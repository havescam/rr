1. Вариант 1. Жадный алгоритм для вершинного покрытия
Задача: реализовать жадный 2-аппроксимационный алгоритм для задачи о вершинном
покрытии. Входные данные представляют собой граф, заданный списком ребер. Необходимо
найти множество вершин, таких что каждое ребро имеет хотя бы один конец в этом множестве.
16
Требования:
- Реализовать алгоритм на всех трех языках (Python, C++, Java)
- Проверить корректность решения
- Вывести размер найденного покрытия и само покрытие
- Оценить коэффициент аппроксимации (должен быть ≤ 2)
Входные данные:
Граф с 10 вершинами (0-9) и следующими ребрами:
(0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,0)
2.Анализ алгоритма
Пошаговый алгоритм 
Инициализация
Создаём множество непокрытых рёбер и пустое покрытие.
remaining_edges = set(edges)
cover = set()
Пока есть непокрытые рёбра
Продолжаем, пока remaining_edges не опустеет.
Берём любое ребро
Извлекаем одно ребро — его надо покрыть.
u, v = remaining_edges.pop()
Добавляем обе вершины в покрытие
Гарантируем, что ребро (u, v) покрыто.
cover.add(u)
cover.add(v)
Удаляем все рёбра, инцидентные u или v
Эти рёбра уже покрыты, их можно исключить из рассмотрения.
remaining_edges = {(a, b) for a, b in remaining_edges if a not in (u, v) and b not in (u, v)}
Возвращаем результат
Даём размер покрытия и список вершин.
return len(cover), sorted(list(cover))
3. Временная сложность - O(m + n)
4. Пояснение временной сложности:
Один проход по рёбрам и константные операции на каждую итерацию, поэтому линейно по числу рёбер.
На каждой итерации выбирается ребро и «вычеркиваются» все инцидентные ему рёбра; суммарно каждое ребро удаляется не более одного раза, значит общий объём работы пропорционален числу рёбер m → O(m) по времени.​
Проверки/пометки вершин и добавление в множество покрытия выполняются за O(1) на шаг, суммарно O(n) по памяти и не меняют линейную асимптотику по времени относительно m.
5. Ответ на контрольный вопрос:
1. Определение приближённых алгоритмов
Приближённый алгоритм — это алгоритм, который находит приближённое решение оптимизационной задачи за полиномиальное время, когда нахождение точного оптимального решения является вычислительно сложным (например, для NP‑сложных задач).
Основная цель приближённых алгоритмов в решении NP‑сложных задач:
Получить «достаточно хорошее» решение за разумное время, когда точное решение найти невозможно или крайне затратно.
Гарантировать качество приближения: доказать, что значение целевой функции найденного решения не хуже, чем в α раз от оптимального (где α≥1 — коэффициент аппроксимации).
Обеспечить полиномиальную временную сложность, в отличие от экспоненциальных алгоритмов точного решения.
