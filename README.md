1. Вариант 1. Жадный алгоритм для вершинного покрытия
Задача: реализовать жадный 2-аппроксимационный алгоритм для задачи о вершинном
покрытии. Входные данные представляют собой граф, заданный списком ребер. Необходимо
найти множество вершин, таких что каждое ребро имеет хотя бы один конец в этом множестве.
16
Требования:
- Реализовать алгоритм на всех трех языках (Python, C++, Java)
- Проверить корректность решения
- Вывести размер найденного покрытия и само покрытие
- Оценить коэффициент аппроксимации (должен быть ≤ 2)
Входные данные:
Граф с 10 вершинами (0-9) и следующими ребрами:
(0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,0)



2.Анализ алгоритма

Инициализация

remaining_edges ← множество из всех рёбер edges; cover ← пустое множество.​

Выбор ребра

Пока remaining_edges не пусто: извлечь произвольное ребро (u, v) операцией pop из remaining_edges.​

Добавление вершин в покрытие

Добавить u и v в множество cover.​

Удаление покрытых рёбер

Заменить remaining_edges на подмножество рёбер, не инцидентных u и v, то есть оставить только (a, b), где a ≠ u, b ≠ u, a ≠ v, b ≠ v.​

Завершение и вывод

Когда remaining_edges пусто, вернуть (|cover|, отсортированный список cover); далее печатать размер, список вершин и коэффициент аппроксимации.
3. Временная сложность - O(m + n)
4. Пояснение временной сложности:
Один проход по рёбрам и константные операции на каждую итерацию, поэтому линейно по числу рёбер.
На каждой итерации выбирается ребро и «вычеркиваются» все инцидентные ему рёбра; суммарно каждое ребро удаляется не более одного раза, значит общий объём работы пропорционален числу рёбер m → O(m) по времени.​
Проверки/пометки вершин и добавление в множество покрытия выполняются за O(1) на шаг, суммарно O(n) по памяти и не меняют линейную асимптотику по времени относительно m.
5. Ответ на контрольный вопрос:
1. Определение приближённых алгоритмов
Приближённый алгоритм — это алгоритм, который находит приближённое решение оптимизационной задачи за полиномиальное время, когда нахождение точного оптимального решения является вычислительно сложным (например, для NP‑сложных задач).
